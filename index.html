<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Zombie Shooter - No Vertical Look</title>
<style>
  body {
    margin: 0; overflow: hidden; background: black; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  canvas { display: block; }
  #ui {
    position: absolute; top: 10px; left: 10px; z-index: 10;
    background: rgba(0,0,0,0.5); padding: 10px 15px; border-radius: 8px;
    user-select: none; font-weight: bold;
  }
</style>
</head>
<body>
<div id="ui">
  Health: <span id="health">100</span><br>
  Weapon: <span id="weapon">Assault Rifle</span><br>
  Controls: WASD = move, ←/→ = turn, Space = shoot, 1/2 = weapon switch
</div>
<canvas id="game" width="960" height="600"></canvas>
<script>
// --- Constants and Setup ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const healthDisplay = document.getElementById('health');
const weaponDisplay = document.getElementById('weapon');

const TILE = 64;
const FOV = Math.PI / 3;
const NUM_RAYS = 300;
const MAX_DEPTH = 1200;
const ZOMBIE_SPEED = 0.05;
const WAVE_INTERVAL = 7000;

let health = 100;
let keys = {};
let spacePressed = false;
let zombies = [];
let bullets = [];
let lastWaveTime = 0;

const player = {
  x: TILE * 3 + TILE/2,
  y: TILE * 3 + TILE/2,
  angle: 0
};

const weapons = {
  rifle: {
    name: "Assault Rifle",
    fireRate: 120,
    spread: 0.008,
    range: 450,
    damage: 20,
    pellets: 1
  },
  shotgun: {
    name: "Shotgun",
    fireRate: 700,
    spread: 0.28,
    range: 250,
    damage: 10,
    pellets: 6
  }
};

let currentWeapon = "rifle";
let lastShot = 0;
let muzzleFlashTimer = 0;

// Bigger detailed map: # wall, T tree, R rock, S bush, space empty
const map = [
  "##############################",
  "#      T        R      T     #",
  "#  S   #######      ######   #",
  "#          T                S#",
  "#   T           R     ####   #",
  "#       S      T             #",
  "#     R                  S   #",
  "#   #######      T      #### #",
  "#             S              #",
  "#    T      R         S      #",
  "#   S                        #",
  "#   R        ####       T    #",
  "#            T               #",
  "#       S                    #",
  "#          T           ####  #",
  "#    #######          S      #",
  "#                            #",
  "#  T      R     T           S#",
  "#                            #",
  "#      #######        R      #",
  "##############################",
];

// --- Utility Functions ---

function isSolid(x, y) {
  if (x < 0 || y < 0) return true;
  let mapX = Math.floor(x / TILE);
  let mapY = Math.floor(y / TILE);
  if (mapY < 0 || mapY >= map.length || mapX < 0 || mapX >= map[0].length) return true;
  const block = map[mapY][mapX];
  return block === '#' || block === 'T' || block === 'R' || block === 'S';
}

function shadeColor(col, percent) {
  const f = parseInt(col.slice(1),16),
        t = percent < 0 ? 0 : 255,
        p = percent < 0 ? -percent : percent,
        R = f >> 16,
        G = f >> 8 & 0x00FF,
        B = f & 0x0000FF;
  return "rgb(" + 
    (Math.round((t - R) * p) + R) + "," + 
    (Math.round((t - G) * p) + G) + "," + 
    (Math.round((t - B) * p) + B) + ")";
}

// --- Drawing functions ---

function drawSky() {
  let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / 2);
  gradient.addColorStop(0, "#87CEEB");
  gradient.addColorStop(1, "#4682B4");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
}

function drawFloor() {
  ctx.fillStyle = "#228B22";
  ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);
}

function castRays() {
  const angleStep = FOV / NUM_RAYS;
  let rayAngle = player.angle - FOV / 2;
  for (let i = 0; i < NUM_RAYS; i++) {
    let sin = Math.sin(rayAngle);
    let cos = Math.cos(rayAngle);
    for (let depth = 0; depth < MAX_DEPTH; depth++) {
      let x = player.x + cos * depth;
      let y = player.y + sin * depth;
      let mapX = Math.floor(x / TILE);
      let mapY = Math.floor(y / TILE);
      if (mapY < 0 || mapY >= map.length || mapX < 0 || mapX >= map[0].length) break;
      let block = map[mapY][mapX];
      if (block !== ' ') {
        let color;
        if (block === '#') color = "#654321";
        else if (block === 'T') color = "#006400";
        else if (block === 'R') color = "#708090";
        else if (block === 'S') color = "#2E8B57";
        else color = "white";

        const wallHeight = 20000 / (depth + 1);
        ctx.fillStyle = shadeColor(color, -depth / 600);
        const screenX = i * (canvas.width / NUM_RAYS);
        ctx.fillRect(screenX, (canvas.height - wallHeight) / 2, canvas.width / NUM_RAYS + 1, wallHeight);
        break;
      }
    }
    rayAngle += angleStep;
  }
}

function drawZombies() {
  zombies.forEach(z => {
    let dx = z.x - player.x;
    let dy = z.y - player.y;
    let distance = Math.sqrt(dx * dx + dy * dy);
    let angleToZombie = Math.atan2(dy, dx) - player.angle;
    if (angleToZombie > Math.PI) angleToZombie -= 2 * Math.PI;
    if (angleToZombie < -Math.PI) angleToZombie += 2 * Math.PI;

    if (Math.abs(angleToZombie) < FOV / 2) {
      let size = 6000 / (distance + 1);
      let x = (canvas.width / 2) + Math.tan(angleToZombie) * canvas.width - size / 2;
      let y = canvas.height / 2 - size / 2;

      // Draw improved zombie: a green 3D cube-ish shape
      ctx.fillStyle = shadeColor("#008000", -distance/400);
      ctx.fillRect(x, y, size, size);

      // Simple eyes
      ctx.fillStyle = "red";
      ctx.fillRect(x + size*0.25, y + size*0.3, size*0.1, size*0.1);
      ctx.fillRect(x + size*0.65, y + size*0.3, size*0.1, size*0.1);

      // Health bar above zombie
      const hpWidth = size * (z.health || 100) / 100;
      ctx.fillStyle = "red";
      ctx.fillRect(x, y - 10, size, 5);
      ctx.fillStyle = "lime";
      ctx.fillRect(x, y - 10, hpWidth, 5);
      ctx.strokeStyle = "black";
      ctx.strokeRect(x, y - 10, size, 5);
    }
  });
}

function drawBullets() {
  ctx.fillStyle = "yellow";
  bullets.forEach(b => {
    let dx = b.x - player.x;
    let dy = b.y - player.y;
    let distance = Math.sqrt(dx * dx + dy * dy);
    let angleToBullet = Math.atan2(dy, dx) - player.angle;
    if (angleToBullet > Math.PI) angleToBullet -= 2 * Math.PI;
    if (angleToBullet < -Math.PI) angleToBullet += 2 * Math.PI;
    if (Math.abs(angleToBullet) < FOV / 2) {
      let size = 5000 / (distance + 1);
      let x = (canvas.width / 2) + Math.tan(angleToBullet) * canvas.width;
      let y = canvas.height / 2;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, 2 * Math.PI);
      ctx.fill();
    }
  });
}

function drawGun() {
  const gunWidth = 160;
  const gunHeight = 100;
  const x = canvas.width / 2 - gunWidth / 2;
  const y = canvas.height - gunHeight - 20;

  ctx.fillStyle = "#555";
  ctx.fillRect(x, y, gunWidth, gunHeight);

  ctx.fillStyle = "#222";
  ctx.fillRect(x + gunWidth * 0.4, y - 20, gunWidth * 0.2, 20);

  if (muzzleFlashTimer > 0) {
    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.moveTo(x + gunWidth * 0.5, y - 20);
    ctx.lineTo(x + gunWidth * 0.6, y - 40);
    ctx.lineTo(x + gunWidth * 0.4, y - 40);
    ctx.fill();
    muzzleFlashTimer--;
  }
}

// --- Game logic ---

function tryMove(newX, newY) {
  const radius = 20;
  const points = [
    {x: newX - radius, y: newY - radius},
    {x: newX + radius, y: newY - radius},
    {x: newX - radius, y: newY + radius},
    {x: newX + radius, y: newY + radius}
  ];
  for (let p of points) {
    if (isSolid(p.x, p.y)) return false;
  }
  return true;
}

function updateZombies(dt) {
  zombies.forEach(z => {
    let dx = player.x - z.x;
    let dy = player.y - z.y;
    let dist = Math.hypot(dx, dy);
    if (dist > 5) {
      const speed = ZOMBIE_SPEED * Math.min(dt, 50);
      z.x += (dx / dist) * speed;
      z.y += (dy / dist) * speed;
    } else {
      health -= 15 * dt / 1000;
    }
  });
  // Remove dead zombies
  zombies = zombies.filter(z => z.health > 0);
}

function spawnWave() {
  for (let i = 0; i < 8; i++) {
    let angle = Math.random() * Math.PI * 2;
    let dist = 350 + Math.random() * 250;
    zombies.push({
      x: player.x + Math.cos(angle) * dist,
      y: player.y + Math.sin(angle) * dist,
      health: 100
    });
  }
}

function fireWeapon() {
  const now = performance.now();
  const weapon = weapons[currentWeapon];
  if (now - lastShot < weapon.fireRate) return;
  lastShot = now;

  muzzleFlashTimer = 5;

  for (let i = 0; i < weapon.pellets; i++) {
    const spread = (Math.random() - 0.5) * weapon.spread * 2;
    const angle = player.angle + spread;

    bullets.push({
      x: player.x,
      y: player.y,
      angle: angle,
      speed: 20,
      range: weapon.range,
      damage: weapon.damage,
      traveled: 0
    });
  }
}

function updateBullets(dt) {
  bullets = bullets.filter(bullet => {
    const moveDist = bullet.speed * (dt / 16);
    bullet.x += Math.cos(bullet.angle) * moveDist;
    bullet.y += Math.sin(bullet.angle) * moveDist;
    bullet.traveled += moveDist;

    let hit = false;
    zombies = zombies.filter(z => {
      let dx = z.x - bullet.x;
      let dy = z.y - bullet.y;
      let dist = Math.hypot(dx, dy);
      if (dist < 40) {
        z.health -= bullet.damage;
        hit = true;
        return z.health > 0;
      }
      return true;
    });

    // Also check walls for bullet removal
    if (isSolid(bullet.x, bullet.y)) return false;

    return !hit && bullet.traveled < bullet.range;
  });
}

// --- Controls ---
document.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  keys[key] = true;
  if (e.code === "Space") spacePressed = true;

  if (key === "1") {
    currentWeapon = "rifle";
    weaponDisplay.textContent = weapons[currentWeapon].name;
  }
  if (key === "2") {
    currentWeapon = "shotgun";
    weaponDisplay.textContent = weapons[currentWeapon].name;
  }
});

document.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  keys[key] = false;
  if (e.code === "Space") spacePressed = false;
});

// --- Main Game Loop ---
let lastTime = performance.now();

function gameLoop(timestamp) {
  let dt = timestamp - lastTime;
  lastTime = timestamp;

  const speed = 2.2;
  let newX = player.x;
  let newY = player.y;

  // Movement WASD
  if (keys["w"]) {
    newX += Math.cos(player.angle) * speed;
    newY += Math.sin(player.angle) * speed;
  }
  if (keys["s"]) {
    newX -= Math.cos(player.angle) * speed;
    newY -= Math.sin(player.angle) * speed;
  }
  if (keys["a"]) {
    newX += Math.cos(player.angle - Math.PI / 2) * speed;
    newY += Math.sin(player.angle - Math.PI / 2) * speed;
  }
  if (keys["d"]) {
    newX += Math.cos(player.angle + Math.PI / 2) * speed;
    newY += Math.sin(player.angle + Math.PI / 2) * speed;
  }

  // Collision check
  if (tryMove(newX, player.y)) player.x = newX;
  if (tryMove(player.x, newY)) player.y = newY;

  // Look around arrow keys (only left/right)
  if (keys["arrowleft"]) player.angle -= 0.012;
  if (keys["arrowright"]) player.angle += 0.012;

  if (spacePressed) fireWeapon();

  if (timestamp - lastWaveTime > WAVE_INTERVAL) {
    spawnWave();
    lastWaveTime = timestamp;
  }

  updateZombies(dt);
  updateBullets(dt);

  drawSky();
  drawFloor();
  castRays();
  drawBullets();
  drawZombies();
  drawGun();

  // Draw crosshair
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2 - 12, canvas.height / 2);
  ctx.lineTo(canvas.width / 2 + 12, canvas.height / 2);
  ctx.moveTo(canvas.width / 2, canvas.height / 2 - 12);
  ctx.lineTo(canvas.width / 2, canvas.height / 2 + 12);
  ctx.stroke();

  healthDisplay.textContent = Math.max(0, Math.floor(health));

  if (health > 0) requestAnimationFrame(gameLoop);
  else {
    ctx.fillStyle = "red";
    ctx.font = "64px Arial Black, Gadget, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("YOU DIED", canvas.width / 2, canvas.height / 2);
  }
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
