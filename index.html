<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bullet Break: Crowd Control</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    background: linear-gradient(to bottom, #2c3e50 0%, #000000 100%); /* Darker, grittier */
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    user-select: none;
    font-family: 'Press+Start+2P', cursive;
    color: #fff;
  }

  canvas {
    background: rgba(10, 10, 20, 0.4);
    display: block;
    border: 3px solid rgba(255, 255, 255, 0.4);
    border-radius: 15px;
    box-shadow:
      0 8px 20px rgba(0, 0, 0, 0.4),
      inset 0 0 40px rgba(255, 255, 255, 0.1);
  }

  #score {
    position: absolute;
    top: 15px;
    font-size: 30px;
    letter-spacing: 2px;
    text-shadow: 2px 2px 6px #0008;
    user-select: none;
  }

  #message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    text-align: center;
    color: #fff;
    text-shadow: 2px 2px 6px #000c;
    user-select: none;
    pointer-events: none;
    white-space: pre;
  }
</style>
</head>
<body>
<div id="score">Targets Hit: 0</div>
<div id="message">Press Space to Shoot</div>
<canvas id="game" width="400" height="600"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  
  const lerp = (start, end, amt) => (1 - amt) * start + amt * end;

  // --- NEW SOUNDS ---
  const sounds = {
    thrust: new Audio('https://freesound.org/data/previews/341/341695_62469-lq.mp3'),
    hit: new Audio('https://freesound.org/data/previews/253/253174_4103908-lq.mp3'), // Impact sound
    gunshot: new Audio('https://freesound.org/data/previews/58/58245_599498-lq.mp3'),
    fail: new Audio('https://freesound.org/data/previews/173/173859_2193233-lq.mp3') // Fail sound
  };

  sounds.thrust.volume = 0.15;
  sounds.hit.volume = 0.4;
  sounds.gunshot.volume = 0.3;
  sounds.fail.volume = 0.3;

  // --- BULLET (Player) ---
  const bullet = {
    startX: 90,
    x: -30,
    y: HEIGHT / 2,
    width: 35,
    height: 12,
    gravity: 0.35,
    lift: -7,
    velocity: 0,
    rotation: 0,
    targetRotation: 0,
    applyThrust() {
      this.velocity = this.lift;
      sounds.thrust.currentTime = 0;
      sounds.thrust.play();
    },
    update() {
      this.velocity += this.gravity;
      this.y += this.velocity;
      
      this.targetRotation = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, this.velocity * 0.05));
      this.rotation = lerp(this.rotation, this.targetRotation, 0.1);

      if (this.y + this.height > HEIGHT || this.y < 0) {
        sounds.fail.play();
        gameState = 'gameover';
        messageEl.textContent = 'Out of Bounds\nPress Space to Restart';
        messageEl.style.display = 'block';
      }
    },
    draw() {
      ctx.save();
      ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
      ctx.rotate(this.rotation);
      ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));

      const grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
      grad.addColorStop(0, '#fefefe');
      grad.addColorStop(0.5, '#d4af37');
      grad.addColorStop(1, '#b8860b');
      ctx.fillStyle = grad;

      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x + this.width - 5, this.y);
      ctx.lineTo(this.x + this.width, this.y + this.height / 2);
      ctx.lineTo(this.x + this.width - 5, this.y + this.height);
      ctx.lineTo(this.x, this.y + this.height);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }
  };
  
  // --- GUN ANIMATION (FIXED BARREL POSITION) ---
  const gun = {
    x: 0,
    width: 110,
    height: 60,
    recoil: 0,
    flashOpacity: 0,
    barrelOffsetY: 18, // The vertical center of the barrel relative to gun's top
    get y() {
      return bullet.y - this.barrelOffsetY - bullet.height/2;
    },
    draw() {
      const gunY = this.y;
      const gunX = this.x - this.recoil;
      
      if(this.flashOpacity > 0) {
        ctx.fillStyle = `rgba(255, 223, 0, ${this.flashOpacity})`;
        ctx.beginPath();
        const flashX = gunX + this.width - 15;
        const flashY = gunY + this.barrelOffsetY + 5;
        ctx.moveTo(flashX, flashY);
        for(let i = 0; i < 8; i++) {
          const angle = i * Math.PI / 4 + Math.random() * 0.2;
          const length = (i % 2 === 0) ? 45 : 22;
          ctx.lineTo(flashX + Math.cos(angle) * length, flashY + Math.sin(angle) * length);
        }
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.fillStyle = '#212529';
      ctx.beginPath();
      ctx.moveTo(gunX + 20, gunY + 30);
      ctx.lineTo(gunX + 15, gunY + 58);
      ctx.lineTo(gunX + 45, gunY + 58);
      ctx.lineTo(gunX + 40, gunY + 30);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = '#343a40';
      ctx.fillRect(gunX, gunY, this.width - 10, 32);
      
      ctx.fillStyle = '#495057';
      ctx.fillRect(gunX, gunY + this.barrelOffsetY, this.width, 10);
    }
  };

  // --- TARGETS (PEOPLE SILHOUETTES) ---
  const targetWidth = 30;
  const targetHeight = 60;
  const targetSpeed = 3;
  let targets = [];

  function createTarget() {
    const yPos = Math.random() * (HEIGHT - targetHeight - 40) + 20; // 20px padding
    targets.push({
      x: WIDTH,
      y: yPos,
      width: targetWidth,
      height: targetHeight,
    });
  }

  function drawTarget(t) {
    ctx.fillStyle = '#f0f0f0'; // Light grey silhouette
    // Body
    ctx.fillRect(t.x, t.y + 15, t.width, t.height - 15);
    // Head
    ctx.beginPath();
    ctx.arc(t.x + t.width / 2, t.y + 15, t.width / 2, 0, Math.PI * 2);
    ctx.fill();
  }

  // --- HIT EFFECT (RED PARTICLES) ---
  let particles = [];
  function createHitEffect(x, y) {
    for (let i = 0; i < 30; i++) {
      particles.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10,
        alpha: 1,
        size: Math.random() * 3 + 1,
        color: `hsl(${Math.random() * 20}, 100%, 50%)` // Hues of red/orange
      });
    }
  }

  function updateAndDrawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.alpha -= 0.04;

      if (p.alpha <= 0) {
        particles.splice(i, 1);
      } else {
        ctx.fillStyle = `rgba(255, 0, 0, ${p.alpha})`;
        ctx.fillRect(p.x, p.y, p.size, p.size);
      }
    }
  }

  // --- GAME STATE & LOOP ---
  let score = 0;
  let frames = 0;
  let gameState = 'start';
  let animationFrame = 0;

  function resetGame() {
    targets = [];
    particles = [];
    score = 0;
    frames = 0;
    bullet.y = HEIGHT / 2;
    bullet.velocity = 0;
    bullet.rotation = 0;
    bullet.x = -bullet.width;
    gameState = 'start';
    scoreEl.textContent = 'Targets Hit: 0';
    messageEl.textContent = 'Press Space to Shoot';
    messageEl.style.display = 'block';
  }

  function checkCollision(a, b) {
    return (
      a.x < b.x + b.width &&
      a.x + a.width > b.x &&
      a.y < b.y + b.height &&
      a.y + a.height > b.y
    );
  }

  function update() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    
    for (let t of targets) {
      drawTarget(t);
    }
    updateAndDrawParticles();

    if (gameState === 'start') {
      gun.draw();
      messageEl.style.display = 'block';
    } else if (gameState === 'shooting') {
        messageEl.style.display = 'none';
        animationFrame++;
        
        gun.recoil = Math.sin(animationFrame * Math.PI / 30) * 20;
        gun.flashOpacity = Math.max(0, 1 - animationFrame / 15);
        bullet.x = lerp(-bullet.width, bullet.startX, animationFrame / 30);
        bullet.y = gun.y + gun.barrelOffsetY;

        gun.draw();
        bullet.draw();

        if (animationFrame > 30) {
            gameState = 'playing';
            bullet.x = bullet.startX;
            gun.recoil = 0;
            gun.flashOpacity = 0;
        }

    } else if (gameState === 'playing') {
      messageEl.style.display = 'none';

      bullet.update();
      bullet.draw();

      if (frames % 60 === 0) { // Spawn a new target every second
        createTarget();
      }

      // Iterate backwards to safely remove items
      for (let i = targets.length - 1; i >= 0; i--) {
        const t = targets[i];
        t.x -= targetSpeed;

        if (checkCollision(bullet, t)) {
          sounds.hit.play();
          createHitEffect(t.x + t.width / 2, t.y + t.height / 2);
          score++;
          scoreEl.textContent = `Targets Hit: ${score}`;
          targets.splice(i, 1); // Remove hit target
          continue; // Skip to next target
        }
        
        // GAME OVER: Target escaped
        if (t.x + t.width < 0) {
          sounds.fail.play();
          gameState = 'gameover';
          messageEl.textContent = 'Target Escaped!\nPress Space to Restart';
          messageEl.style.display = 'block';
        }
      }
    } else if (gameState === 'gameover') {
      // Game over, do nothing
    }

    frames++;
    requestAnimationFrame(update);
  }

  function handleInput() {
    if (gameState === 'start') {
      sounds.gunshot.currentTime = 0;
      sounds.gunshot.play();
      gameState = 'shooting';
      animationFrame = 0;
    } else if (gameState === 'playing') {
      bullet.applyThrust();
    } else if (gameState === 'gameover') {
      resetGame();
    }
  }

  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      e.preventDefault();
      handleInput();
    }
  });
  window.addEventListener('mousedown', () => handleInput());

  resetGame();
  update();
})();
</script>
</body>
</html>
