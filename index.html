<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bullet Break: Shatterpoint</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    background: linear-gradient(to bottom, #141e30 0%, #243b55 100%);
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    user-select: none;
    font-family: 'Press+Start+2P', cursive;
    color: #fff;
  }

  canvas {
    background: rgba(10, 10, 20, 0.4); /* Darker, more serious background */
    display: block;
    border: 3px solid rgba(255, 255, 255, 0.4);
    border-radius: 15px;
    box-shadow:
      0 8px 20px rgba(0, 0, 0, 0.4),
      inset 0 0 40px rgba(255, 255, 255, 0.1);
  }

  #score {
    position: absolute;
    top: 15px;
    font-size: 40px;
    letter-spacing: 2px;
    text-shadow: 2px 2px 6px #0008;
    user-select: none;
  }

  #message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    text-align: center;
    color: #fff;
    text-shadow: 2px 2px 6px #000c;
    user-select: none;
    pointer-events: none;
    white-space: pre;
  }
</style>
</head>
<body>
<div id="score">0</div>
<div id="message">Press Space to Shoot</div>
<canvas id="game" width="400" height="600"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;
  
  // --- HELPER FUNCTION FOR SMOOTHING ---
  const lerp = (start, end, amt) => (1 - amt) * start + amt * end;

  // --- SOUNDS ---
  const sounds = {
    thrust: new Audio('https://freesound.org/data/previews/341/341695_62469-lq.mp3'),
    hit: new Audio('https://freesound.org/data/previews/23/23389_133742-lq.mp3'),
    point: new Audio('https://freesound.org/data/previews/43/43132_359333-lq.mp3'),
    gunshot: new Audio('https://freesound.org/data/previews/58/58245_599498-lq.mp3')
  };

  sounds.thrust.volume = 0.15;
  sounds.hit.volume = 0.5;
  sounds.point.volume = 0.2;
  sounds.gunshot.volume = 0.3;

  // --- IMPROVED BULLET ---
  const bullet = {
    startX: 90,
    x: -30,
    y: HEIGHT / 2,
    width: 35,
    height: 12,
    gravity: 0.35,
    lift: -7,
    velocity: 0,
    rotation: 0,
    targetRotation: 0,
    applyThrust() {
      this.velocity = this.lift;
      sounds.thrust.currentTime = 0;
      sounds.thrust.play();
    },
    update() {
      this.velocity += this.gravity;
      this.y += this.velocity;
      
      // Calculate target rotation based on velocity (tilts up/down)
      this.targetRotation = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, this.velocity * 0.05));
      // Smoothly interpolate to the target rotation
      this.rotation = lerp(this.rotation, this.targetRotation, 0.1);

      if (this.y + this.height > HEIGHT) {
        this.y = HEIGHT - this.height;
        this.velocity = 0;
      }
      if (this.y < 0) {
        this.y = 0;
        this.velocity = 0;
      }
    },
    draw() {
      ctx.save();
      ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
      ctx.rotate(this.rotation);
      ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));

      // Speed trail
      ctx.fillStyle = 'rgba(255, 223, 0, 0.3)';
      ctx.beginPath();
      ctx.moveTo(this.x - 10, this.y + this.height / 2 - 2);
      ctx.lineTo(this.x, this.y + this.height / 2);
      ctx.lineTo(this.x - 10, this.y + this.height / 2 + 2);
      ctx.closePath();
      ctx.fill();
      
      // Bullet body with gradient for metallic look
      const grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
      grad.addColorStop(0, '#fefefe');
      grad.addColorStop(0.5, '#d4af37');
      grad.addColorStop(1, '#b8860b');
      ctx.fillStyle = grad;

      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x + this.width - 5, this.y);
      ctx.lineTo(this.x + this.width, this.y + this.height / 2);
      ctx.lineTo(this.x + this.width - 5, this.y + this.height);
      ctx.lineTo(this.x, this.y + this.height);
      ctx.closePath();
      ctx.fill();

      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fillRect(this.x + 5, this.y + 2, this.width - 15, 2);

      ctx.restore();
    }
  };
  
  // --- IMPROVED GUN ---
  const gun = {
    x: 0,
    y: 0,
    width: 110,
    height: 60,
    recoil: 0,
    flashOpacity: 0,
    draw() {
      const gunY = bullet.y - (this.height - bullet.height) / 2 - 10;
      const gunX = this.x - this.recoil;
      
      if(this.flashOpacity > 0) {
        ctx.fillStyle = `rgba(255, 223, 0, ${this.flashOpacity})`;
        ctx.beginPath();
        const flashX = gunX + this.width - 15;
        const flashY = gunY + 18;
        ctx.moveTo(flashX, flashY);
        for(let i = 0; i < 8; i++) {
          const angle = i * Math.PI / 4 + Math.random() * 0.2;
          const length = (i % 2 === 0) ? 45 : 22;
          ctx.lineTo(flashX + Math.cos(angle) * length, flashY + Math.sin(angle) * length);
        }
        ctx.closePath();
        ctx.fill();
      }
      
      // Grip
      ctx.fillStyle = '#212529';
      ctx.beginPath();
      ctx.moveTo(gunX + 20, gunY + 30);
      ctx.lineTo(gunX + 15, gunY + 58);
      ctx.lineTo(gunX + 45, gunY + 58);
      ctx.lineTo(gunX + 40, gunY + 30);
      ctx.closePath();
      ctx.fill();
      
      // Main Body (Slide)
      ctx.fillStyle = '#343a40';
      ctx.fillRect(gunX, gunY, this.width - 10, 32);
      
      // Barrel
      ctx.fillStyle = '#495057';
      ctx.fillRect(gunX, gunY + 12, this.width, 10);
    }
  };

  // --- GLASS PANEL OBSTACLES ---
  const panelWidth = 90;
  const panelGap = 160;
  const panelSpeed = 2.5;
  let panels = [];

  function createPanel() {
    const minHeight = 60;
    const maxHeight = HEIGHT - panelGap - 60;
    const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
    const bottomHeight = HEIGHT - (topHeight + panelGap);

    const generateJaggedPoints = (numPoints, maxOffset) => {
      let points = [];
      for (let i = 0; i <= numPoints; i++) {
        points.push({
          x: (panelWidth / numPoints) * i,
          y: Math.random() * maxOffset
        });
      }
      return points;
    };

    panels.push({
      x: WIDTH,
      topHeight: topHeight,
      bottomY: topHeight + panelGap,
      bottomHeight: bottomHeight,
      passed: false,
      jaggedPoints: generateJaggedPoints(8, 20)
    });
  }

  function drawPanel(p) {
    ctx.fillStyle = 'rgba(173, 216, 230, 0.35)';
    ctx.strokeStyle = 'rgba(220, 240, 255, 0.6)';
    ctx.lineWidth = 2;

    // Top Panel
    ctx.beginPath();
    ctx.moveTo(p.x, 0);
    ctx.lineTo(p.x + panelWidth, 0);
    ctx.lineTo(p.x + panelWidth, p.topHeight);
    p.jaggedPoints.forEach(point => ctx.lineTo(p.x + point.x, p.topHeight - point.y));
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Bottom Panel
    ctx.beginPath();
    ctx.moveTo(p.x, HEIGHT);
    ctx.lineTo(p.x + panelWidth, HEIGHT);
    ctx.lineTo(p.x + panelWidth, p.bottomY);
    p.jaggedPoints.slice().reverse().forEach(point => ctx.lineTo(p.x + point.x, p.bottomY + point.y));
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  // --- SHATTER EFFECT ---
  let particles = [];
  function createShatterEffect(x, y) {
    for (let i = 0; i < 40; i++) {
      particles.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 0.5) * 8,
        alpha: 1,
        size: Math.random() * 4 + 1,
        gravity: 0.2
      });
    }
  }

  function updateAndDrawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.vx *= 0.98;
      p.vy += p.gravity;
      p.x += p.vx;
      p.y += p.vy;
      p.alpha -= 0.02;

      if (p.alpha <= 0) {
        particles.splice(i, 1);
      } else {
        ctx.fillStyle = `rgba(220, 240, 255, ${p.alpha})`;
        ctx.fillRect(p.x, p.y, p.size, p.size);
      }
    }
  }

  // --- GAME STATE & LOOP ---
  let score = 0;
  let frames = 0;
  let gameState = 'start';
  let animationFrame = 0;

  function resetGame() {
    panels = [];
    particles = [];
    score = 0;
    frames = 0;
    bullet.y = HEIGHT / 2;
    bullet.velocity = 0;
    bullet.rotation = 0;
    bullet.x = -bullet.width;
    gameState = 'start';
    scoreEl.textContent = '0';
    messageEl.textContent = 'Press Space to Shoot';
    messageEl.style.display = 'block';
  }

  function collision(p) {
      const bx = bullet.x;
      const by = bullet.y;
      const bw = bullet.width;
      const bh = bullet.height;

      if (bx + bw > p.x && bx < p.x + panelWidth) {
          if (by < p.topHeight || by + bh > p.bottomY) {
              return true;
          }
      }
      return false;
  }

  function update() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    
    for (let p of panels) {
      drawPanel(p);
    }
    updateAndDrawParticles();

    if (gameState === 'start') {
      gun.draw();
      bullet.y = HEIGHT / 2;
      messageEl.style.display = 'block';
    } else if (gameState === 'shooting') {
        messageEl.style.display = 'none';
        animationFrame++;
        
        gun.recoil = Math.sin(animationFrame * Math.PI / 30) * 20;
        gun.flashOpacity = Math.max(0, 1 - animationFrame / 15);
        bullet.x = (bullet.startX + bullet.width) * (animationFrame / 30) - bullet.width;

        gun.draw();
        bullet.draw();

        if (animationFrame > 30) {
            gameState = 'playing';
            bullet.x = bullet.startX;
            gun.recoil = 0;
            gun.flashOpacity = 0;
        }

    } else if (gameState === 'playing') {
      messageEl.style.display = 'none';

      bullet.update();
      bullet.draw();

      if (frames % 80 === 0) {
        createPanel();
      }

      for (let p of panels) {
        p.x -= panelSpeed;
        if (collision(p)) {
          sounds.hit.play();
          createShatterEffect(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2);
          gameState = 'gameover';
          messageEl.textContent = 'Shattered\nPress Space to Restart';
          messageEl.style.display = 'block';
        }
        if (!p.passed && p.x + panelWidth < bullet.x) {
          score++;
          p.passed = true;
          scoreEl.textContent = score;
          sounds.point.play();
        }
      }
      panels = panels.filter(p => p.x + panelWidth > 0);

    } else if (gameState === 'gameover') {
      // Don't draw the bullet, it has shattered
    }

    frames++;
    requestAnimationFrame(update);
  }

  // --- CONTROLS ---
  function handleInput() {
    if (gameState === 'start') {
      sounds.gunshot.currentTime = 0;
      sounds.gunshot.play();
      gameState = 'shooting';
      animationFrame = 0;
    } else if (gameState === 'playing') {
      bullet.applyThrust();
    } else if (gameState === 'gameover') {
      resetGame();
    }
  }

  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      e.preventDefault();
      handleInput();
    }
  });
  window.addEventListener('mousedown', () => handleInput());

  resetGame();
  update();
})();
</script>
</body>
</html>
