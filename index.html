<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bullet Break</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    background: linear-gradient(to bottom, #141e30 0%, #243b55 100%);
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    user-select: none;
    font-family: 'Press Start 2P', cursive;
    color: #fff;
  }

  canvas {
    /* Represents the glass pane */
    background: rgba(173, 216, 230, 0.2); /* Light blue, semi-transparent */
    display: block;
    border: 3px solid rgba(255, 255, 255, 0.4);
    border-radius: 15px;
    box-shadow:
      0 8px 20px rgba(0, 0, 0, 0.4),
      inset 0 0 40px rgba(255, 255, 255, 0.1);
  }

  #score {
    position: absolute;
    top: 15px;
    font-size: 40px;
    letter-spacing: 2px;
    text-shadow: 2px 2px 6px #0008;
    user-select: none;
  }

  #message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    text-align: center;
    color: #fff;
    text-shadow: 2px 2px 6px #000c;
    user-select: none;
    pointer-events: none;
    white-space: pre; /* Allows newline characters */
  }
</style>
</head>
<body>
<div id="score">0</div>
<div id="message">Press Space to Shoot</div>
<canvas id="game" width="400" height="600"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const messageEl = document.getElementById('message');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // --- NEW SOUNDS ---
  const sounds = {
    thrust: new Audio('https://freesound.org/data/previews/341/341695_62469-lq.mp3'),
    hit: new Audio('https://freesound.org/data/previews/23/23389_133742-lq.mp3'), // Glass break
    point: new Audio('https://freesound.org/data/previews/43/43132_359333-lq.mp3'), // Ricochet
    gunshot: new Audio('https://freesound.org/data/previews/58/58245_599498-lq.mp3')
  };

  sounds.thrust.volume = 0.2;
  sounds.hit.volume = 0.4;
  sounds.point.volume = 0.3;
  sounds.gunshot.volume = 0.3;

  // --- PLAYER IS NOW A BULLET ---
  const bullet = {
    startX: 80,
    x: -30, // Starts off-screen
    y: HEIGHT / 2,
    width: 30,
    height: 10,
    gravity: 0.4,
    lift: -8,
    velocity: 0,
    applyThrust() {
      this.velocity = this.lift;
      sounds.thrust.currentTime = 0;
      sounds.thrust.play();
    },
    update() {
      this.velocity += this.gravity;
      this.velocity *= 0.95; // air resistance
      this.y += this.velocity;

      // Keep bullet within the screen
      if (this.y + this.height > HEIGHT) {
        this.y = HEIGHT - this.height;
        this.velocity = 0;
      }
      if (this.y < 0) {
        this.y = 0;
        this.velocity = 0;
      }
    },
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);

      // Bullet Casing (darker grey)
      ctx.fillStyle = '#6c757d';
      ctx.beginPath();
      ctx.rect(0, 0, this.width - 10, this.height);
      ctx.fill();

      // Bullet Tip (brassy color)
      ctx.fillStyle = '#d4af37';
      ctx.beginPath();
      ctx.moveTo(this.width - 10, 0);
      ctx.lineTo(this.width, this.height / 2);
      ctx.lineTo(this.width - 10, this.height);
      ctx.closePath();
      ctx.fill();
      
      ctx.restore();
    }
  };
  
  // --- GUN FOR SHOOTING ANIMATION ---
  const gun = {
    x: 0,
    y: 0,
    width: 100,
    height: 50,
    recoil: 0,
    flashOpacity: 0,
    draw() {
      const gunY = bullet.y - (this.height - bullet.height) / 2;
      const gunX = this.x - this.recoil;
      
      // Draw muzzle flash
      if(this.flashOpacity > 0) {
        ctx.fillStyle = `rgba(255, 223, 0, ${this.flashOpacity})`;
        ctx.beginPath();
        ctx.moveTo(gunX + this.width, gunY + this.height / 2);
        for(let i = 0; i < 8; i++) {
          const angle = i * Math.PI / 4;
          const length = (i % 2 === 0) ? 40 : 20;
          ctx.lineTo(
            gunX + this.width + Math.cos(angle) * length,
            gunY + this.height / 2 + Math.sin(angle) * length
          );
        }
        ctx.closePath();
        ctx.fill();
      }

      // Draw gun body
      ctx.fillStyle = '#343a40';
      ctx.fillRect(gunX, gunY, this.width - 20, this.height);
      ctx.fillStyle = '#495057';
      ctx.fillRect(gunX + this.width - 20, gunY + 10, 20, this.height - 20); // Barrel
    }
  };

  // --- OBSTACLES ARE NOW CRACKS IN GLASS ---
  const crackWidth = 80;
  const crackGap = 150;
  const crackSpeed = 2;
  let cracks = [];

  function createCrack() {
    const minHeight = 50;
    const maxHeight = HEIGHT - crackGap - 50;
    const topHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;

    const generateJaggedPoints = (numPoints, maxOffset) => {
      let points = [];
      for (let i = 0; i <= numPoints; i++) {
        points.push({
          x: (crackWidth / numPoints) * i,
          y: (Math.random() - 0.5) * maxOffset
        });
      }
      return points;
    };

    cracks.push({
      x: WIDTH,
      top: topHeight,
      bottom: HEIGHT - (topHeight + crackGap),
      passed: false,
      topPoints: generateJaggedPoints(10, 20),
      bottomPoints: generateJaggedPoints(10, 20)
    });
  }

  // --- NEW DRAWING FUNCTION FOR CRACKS ---
  function drawCrack(x, y, height, isTop, points) {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(x, y);
    if (isTop) {
      ctx.lineTo(x + crackWidth, y);
      ctx.lineTo(x + crackWidth, y + height);
      // Jagged edge
      points.forEach(p => ctx.lineTo(x + p.x, y + height + p.y));
      ctx.lineTo(x, y + height);
    } else {
      // Jagged edge
      points.forEach(p => ctx.lineTo(x + p.x, y + p.y));
      ctx.lineTo(x + crackWidth, y);
      ctx.lineTo(x + crackWidth, y + height);
      ctx.lineTo(x, y + height);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  // --- GAME STATE MANAGEMENT ---
  let score = 0;
  let frames = 0;
  let gameState = 'start'; // 'start', 'shooting', 'playing', 'gameover'
  let animationFrame = 0;

  function resetGame() {
    cracks = [];
    score = 0;
    frames = 0;
    bullet.y = HEIGHT / 2;
    bullet.velocity = 0;
    bullet.x = -bullet.width; // Position bullet off-screen for animation
    gameState = 'start';
    scoreEl.textContent = '0';
    messageEl.textContent = 'Press Space to Shoot';
    messageEl.style.display = 'block';
  }

  function collision(crack) {
    const bx = bullet.x;
    const by = bullet.y;
    const bw = bullet.width;
    const bh = bullet.height;

    // Check collision with the crack's solid parts
    if (bx + bw > crack.x && bx < crack.x + crackWidth) {
      if (by < crack.top || by + bh > HEIGHT - crack.bottom) {
        return true;
      }
    }
    return false;
  }

  // --- MAIN GAME LOOP ---
  function update() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Update and draw cracks for all states except 'start'
    if (gameState !== 'start') {
        for (let p of cracks) {
          drawCrack(p.x, 0, p.top, true, p.topPoints);
          drawCrack(p.x, HEIGHT - p.bottom, p.bottom, false, p.bottomPoints);
        }
    }

    if (gameState === 'start') {
      gun.draw();
      bullet.y = HEIGHT / 2; // Keep gun centered
      messageEl.style.display = 'block';
    } else if (gameState === 'shooting') {
        messageEl.style.display = 'none';
        animationFrame++;
        
        // --- Gun Animation Logic ---
        // Recoil
        gun.recoil = Math.sin(animationFrame * Math.PI / 30) * 15;
        // Muzzle flash
        gun.flashOpacity = Math.max(0, 1 - animationFrame / 15);
        // Move bullet out of gun
        bullet.x = (bullet.startX + bullet.width) * (animationFrame / 30) - bullet.width;

        gun.draw();
        bullet.draw();

        if (animationFrame > 30) {
            gameState = 'playing';
            bullet.x = bullet.startX;
            gun.recoil = 0;
            gun.flashOpacity = 0;
        }

    } else if (gameState === 'playing') {
      messageEl.style.display = 'none';

      bullet.update();
      bullet.draw();

      if (frames % 100 === 0) { // Cracks are slightly further apart
        createCrack();
      }

      for (let i = 0; i < cracks.length; i++) {
        const p = cracks[i];
        p.x -= crackSpeed;

        if (collision(p)) {
          sounds.hit.play();
          gameState = 'gameover';
          messageEl.textContent = 'Shattered\nPress Space to Restart';
          messageEl.style.display = 'block';
        }

        if (!p.passed && p.x + crackWidth < bullet.x) {
          score++;
          p.passed = true;
          scoreEl.textContent = score;
          sounds.point.play();
        }
      }

      cracks = cracks.filter(p => p.x + crackWidth > 0);

      if (bullet.y <= 0 || bullet.y + bullet.height >= HEIGHT) {
        sounds.hit.play();
        gameState = 'gameover';
        messageEl.textContent = 'Shattered\nPress Space to Restart';
        messageEl.style.display = 'block';
      }
    } else if (gameState === 'gameover') {
      bullet.draw();
    }

    frames++;
    requestAnimationFrame(update);
  }

  // --- CONTROLS ---
  function handleInput() {
    if (gameState === 'start') {
      sounds.gunshot.currentTime = 0;
      sounds.gunshot.play();
      gameState = 'shooting';
      animationFrame = 0;
    } else if (gameState === 'playing') {
      bullet.applyThrust();
    } else if (gameState === 'gameover') {
      resetGame();
    }
  }

  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      e.preventDefault();
      handleInput();
    }
  });

  window.addEventListener('mousedown', () => {
    handleInput();
  });

  // Start game
  resetGame();
  update();
})();
</script>
</body>
</html>
